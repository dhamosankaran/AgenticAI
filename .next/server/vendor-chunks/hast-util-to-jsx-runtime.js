"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-to-jsx-runtime";
exports.ids = ["vendor-chunks/hast-util-to-jsx-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! comma-separated-tokens */ \"(ssr)/./node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! devlop */ \"(ssr)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! estree-util-is-identifier-name */ \"(ssr)/./node_modules/estree-util-is-identifier-name/lib/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(ssr)/./node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! space-separated-tokens */ \"(ssr)/./node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-object */ \"(ssr)/./node_modules/style-to-object/esm/index.mjs\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @import {Identifier, Literal, MemberExpression} from 'estree'\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\n * @import {Position} from 'unist'\n * @import {Child, Create, Field, State, Style} from './types.js'\n */ \n\n\n\n\n\n\n\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty;\n/** @type {Map<string, number>} */ const emptyMap = new Map();\nconst cap = /[A-Z]/g;\nconst dashSomething = /-([a-z])/g;\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set([\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tfoot\",\n    \"tr\"\n]);\nconst tableCellElement = new Set([\n    \"td\",\n    \"th\"\n]);\nconst docs = \"https://github.com/syntax-tree/hast-util-to-jsx-runtime\";\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */ function toJsxRuntime(tree, options) {\n    if (!options || options.Fragment === undefined) {\n        throw new TypeError(\"Expected `Fragment` in options\");\n    }\n    const filePath = options.filePath || undefined;\n    /** @type {Create} */ let create;\n    if (options.development) {\n        if (typeof options.jsxDEV !== \"function\") {\n            throw new TypeError(\"Expected `jsxDEV` in options when `development: true`\");\n        }\n        create = developmentCreate(filePath, options.jsxDEV);\n    } else {\n        if (typeof options.jsx !== \"function\") {\n            throw new TypeError(\"Expected `jsx` in production options\");\n        }\n        if (typeof options.jsxs !== \"function\") {\n            throw new TypeError(\"Expected `jsxs` in production options\");\n        }\n        create = productionCreate(filePath, options.jsx, options.jsxs);\n    }\n    /** @type {State} */ const state = {\n        Fragment: options.Fragment,\n        ancestors: [],\n        components: options.components || {},\n        create,\n        elementAttributeNameCase: options.elementAttributeNameCase || \"react\",\n        evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n        filePath,\n        ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n        passKeys: options.passKeys !== false,\n        passNode: options.passNode || false,\n        schema: options.space === \"svg\" ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n        stylePropertyNameCase: options.stylePropertyNameCase || \"dom\",\n        tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n    };\n    const result = one(state, tree, undefined);\n    // JSX element.\n    if (result && typeof result !== \"string\") {\n        return result;\n    }\n    // Text node or something that turned into nothing.\n    return state.create(tree, state.Fragment, {\n        children: result || undefined\n    }, undefined);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function one(state, node, key) {\n    if (node.type === \"element\") {\n        return element(state, node, key);\n    }\n    if (node.type === \"mdxFlowExpression\" || node.type === \"mdxTextExpression\") {\n        return mdxExpression(state, node);\n    }\n    if (node.type === \"mdxJsxFlowElement\" || node.type === \"mdxJsxTextElement\") {\n        return mdxJsxElement(state, node, key);\n    }\n    if (node.type === \"mdxjsEsm\") {\n        return mdxEsm(state, node);\n    }\n    if (node.type === \"root\") {\n        return root(state, node, key);\n    }\n    if (node.type === \"text\") {\n        return text(state, node);\n    }\n}\n/**\n * Handle element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function element(state, node, key) {\n    const parentSchema = state.schema;\n    let schema = parentSchema;\n    if (node.tagName.toLowerCase() === \"svg\" && parentSchema.space === \"html\") {\n        schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n        state.schema = schema;\n    }\n    state.ancestors.push(node);\n    const type = findComponentFromName(state, node.tagName, false);\n    const props = createElementProps(state, node);\n    let children = createChildren(state, node);\n    if (tableElements.has(node.tagName)) {\n        children = children.filter(function(child) {\n            return typeof child === \"string\" ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true;\n        });\n    }\n    addNode(state, props, type, node);\n    addChildren(props, children);\n    // Restore.\n    state.ancestors.pop();\n    state.schema = parentSchema;\n    return state.create(node, type, props, key);\n}\n/**\n * Handle MDX expression.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxExpression(state, node) {\n    if (node.data && node.data.estree && state.evaluater) {\n        const program = node.data.estree;\n        const expression = program.body[0];\n        (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n        // Assume result is a child.\n        return /** @type {Child | undefined} */ state.evaluater.evaluateExpression(expression.expression);\n    }\n    crashEstree(state, node.position);\n}\n/**\n * Handle MDX ESM.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxjsEsmHast} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxEsm(state, node) {\n    if (node.data && node.data.estree && state.evaluater) {\n        // Assume result is a child.\n        return /** @type {Child | undefined} */ state.evaluater.evaluateProgram(node.data.estree);\n    }\n    crashEstree(state, node.position);\n}\n/**\n * Handle MDX JSX.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function mdxJsxElement(state, node, key) {\n    const parentSchema = state.schema;\n    let schema = parentSchema;\n    if (node.name === \"svg\" && parentSchema.space === \"html\") {\n        schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n        state.schema = schema;\n    }\n    state.ancestors.push(node);\n    const type = node.name === null ? state.Fragment : findComponentFromName(state, node.name, true);\n    const props = createJsxElementProps(state, node);\n    const children = createChildren(state, node);\n    addNode(state, props, type, node);\n    addChildren(props, children);\n    // Restore.\n    state.ancestors.pop();\n    state.schema = parentSchema;\n    return state.create(node, type, props, key);\n}\n/**\n * Handle root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Root} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function root(state, node, key) {\n    /** @type {Props} */ const props = {};\n    addChildren(props, createChildren(state, node));\n    return state.create(node, state.Fragment, props, key);\n}\n/**\n * Handle text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Text} node\n *   Current node.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function text(_, node) {\n    return node.value;\n}\n/**\n * Add `node` to props.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Props} props\n *   Props.\n * @param {unknown} type\n *   Type.\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Node.\n * @returns {undefined}\n *   Nothing.\n */ function addNode(state, props, type, node) {\n    // If this is swapped out for a component:\n    if (typeof type !== \"string\" && type !== state.Fragment && state.passNode) {\n        props.node = node;\n    }\n}\n/**\n * Add children to props.\n *\n * @param {Props} props\n *   Props.\n * @param {Array<Child>} children\n *   Children.\n * @returns {undefined}\n *   Nothing.\n */ function addChildren(props, children) {\n    if (children.length > 0) {\n        const value = children.length > 1 ? children : children[0];\n        if (value) {\n            props.children = value;\n        }\n    }\n}\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */ function productionCreate(_, jsx, jsxs) {\n    return create;\n    /** @type {Create} */ function create(_, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const fn = isStaticChildren ? jsxs : jsx;\n        return key ? fn(type, props, key) : fn(type, props);\n    }\n}\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */ function developmentCreate(filePath, jsxDEV) {\n    return create;\n    /** @type {Create} */ function create(node, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_4__.pointStart)(node);\n        return jsxDEV(type, props, key, isStaticChildren, {\n            columnNumber: point ? point.column - 1 : undefined,\n            fileName: filePath,\n            lineNumber: point ? point.line : undefined\n        }, undefined);\n    }\n}\n/**\n * Create props from an element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Element} node\n *   Current element.\n * @returns {Props}\n *   Props.\n */ function createElementProps(state, node) {\n    /** @type {Props} */ const props = {};\n    /** @type {string | undefined} */ let alignValue;\n    /** @type {string} */ let prop;\n    for(prop in node.properties){\n        if (prop !== \"children\" && own.call(node.properties, prop)) {\n            const result = createProperty(state, prop, node.properties[prop]);\n            if (result) {\n                const [key, value] = result;\n                if (state.tableCellAlignToStyle && key === \"align\" && typeof value === \"string\" && tableCellElement.has(node.tagName)) {\n                    alignValue = value;\n                } else {\n                    props[key] = value;\n                }\n            }\n        }\n    }\n    if (alignValue) {\n        // Assume style is an object.\n        const style = /** @type {Style} */ props.style || (props.style = {});\n        style[state.stylePropertyNameCase === \"css\" ? \"text-align\" : \"textAlign\"] = alignValue;\n    }\n    return props;\n}\n/**\n * Create props from a JSX element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\n *   Current JSX element.\n * @returns {Props}\n *   Props.\n */ function createJsxElementProps(state, node) {\n    /** @type {Props} */ const props = {};\n    for (const attribute of node.attributes){\n        if (attribute.type === \"mdxJsxExpressionAttribute\") {\n            if (attribute.data && attribute.data.estree && state.evaluater) {\n                const program = attribute.data.estree;\n                const expression = program.body[0];\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n                const objectExpression = expression.expression;\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(objectExpression.type === \"ObjectExpression\");\n                const property = objectExpression.properties[0];\n                (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(property.type === \"SpreadElement\");\n                Object.assign(props, state.evaluater.evaluateExpression(property.argument));\n            } else {\n                crashEstree(state, node.position);\n            }\n        } else {\n            // For JSX, the author is responsible of passing in the correct values.\n            const name = attribute.name;\n            /** @type {unknown} */ let value;\n            if (attribute.value && typeof attribute.value === \"object\") {\n                if (attribute.value.data && attribute.value.data.estree && state.evaluater) {\n                    const program = attribute.value.data.estree;\n                    const expression = program.body[0];\n                    (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(expression.type === \"ExpressionStatement\");\n                    value = state.evaluater.evaluateExpression(expression.expression);\n                } else {\n                    crashEstree(state, node.position);\n                }\n            } else {\n                value = attribute.value === null ? true : attribute.value;\n            }\n            // Assume a prop.\n            props[name] = /** @type {Props[keyof Props]} */ value;\n        }\n    }\n    return props;\n}\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */ function createChildren(state, node) {\n    /** @type {Array<Child>} */ const children = [];\n    let index = -1;\n    /** @type {Map<string, number>} */ // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n    /* c8 ignore next */ const countsByName = state.passKeys ? new Map() : emptyMap;\n    while(++index < node.children.length){\n        const child = node.children[index];\n        /** @type {string | undefined} */ let key;\n        if (state.passKeys) {\n            const name = child.type === \"element\" ? child.tagName : child.type === \"mdxJsxFlowElement\" || child.type === \"mdxJsxTextElement\" ? child.name : undefined;\n            if (name) {\n                const count = countsByName.get(name) || 0;\n                key = name + \"-\" + count;\n                countsByName.set(name, count + 1);\n            }\n        }\n        const result = one(state, child, key);\n        if (result !== undefined) children.push(result);\n    }\n    return children;\n}\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */ function createProperty(state, prop, value) {\n    const info = (0,property_information__WEBPACK_IMPORTED_MODULE_5__.find)(state.schema, prop);\n    // Ignore nullish and `NaN` values.\n    if (value === null || value === undefined || typeof value === \"number\" && Number.isNaN(value)) {\n        return;\n    }\n    if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_7__.stringify)(value);\n    }\n    // React only accepts `style` as object.\n    if (info.property === \"style\") {\n        let styleObject = typeof value === \"object\" ? value : parseStyle(state, String(value));\n        if (state.stylePropertyNameCase === \"css\") {\n            styleObject = transformStylesToCssCasing(styleObject);\n        }\n        return [\n            \"style\",\n            styleObject\n        ];\n    }\n    return [\n        state.elementAttributeNameCase === \"react\" && info.space ? property_information__WEBPACK_IMPORTED_MODULE_8__.hastToReact[info.property] || info.property : info.attribute,\n        value\n    ];\n}\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */ function parseStyle(state, value) {\n    /** @type {Style} */ const result = {};\n    try {\n        (0,style_to_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value, replacer);\n    } catch (error) {\n        if (!state.ignoreInvalidStyle) {\n            const cause = /** @type {Error} */ error;\n            const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\"Cannot parse `style` attribute\", {\n                ancestors: state.ancestors,\n                cause,\n                ruleId: \"style\",\n                source: \"hast-util-to-jsx-runtime\"\n            });\n            message.file = state.filePath || undefined;\n            message.url = docs + \"#cannot-parse-style-attribute\";\n            throw message;\n        }\n    }\n    return result;\n    /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */ function replacer(name, value) {\n        let key = name;\n        if (key.slice(0, 2) !== \"--\") {\n            if (key.slice(0, 4) === \"-ms-\") key = \"ms-\" + key.slice(4);\n            key = key.replace(dashSomething, toCamel);\n        }\n        result[key] = value;\n    }\n}\n/**\n * Create a JSX name from a string.\n *\n * @param {State} state\n *   To do.\n * @param {string} name\n *   Name.\n * @param {boolean} allowExpression\n *   Allow member expressions and identifiers.\n * @returns {unknown}\n *   To do.\n */ function findComponentFromName(state, name, allowExpression) {\n    /** @type {Identifier | Literal | MemberExpression} */ let result;\n    if (!allowExpression) {\n        result = {\n            type: \"Literal\",\n            value: name\n        };\n    } else if (name.includes(\".\")) {\n        const identifiers = name.split(\".\");\n        let index = -1;\n        /** @type {Identifier | Literal | MemberExpression | undefined} */ let node;\n        while(++index < identifiers.length){\n            /** @type {Identifier | Literal} */ const prop = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(identifiers[index]) ? {\n                type: \"Identifier\",\n                name: identifiers[index]\n            } : {\n                type: \"Literal\",\n                value: identifiers[index]\n            };\n            node = node ? {\n                type: \"MemberExpression\",\n                object: node,\n                property: prop,\n                computed: Boolean(index && prop.type === \"Literal\"),\n                optional: false\n            } : prop;\n        }\n        (0,devlop__WEBPACK_IMPORTED_MODULE_3__.ok)(node, \"always a result\");\n        result = node;\n    } else {\n        result = (0,estree_util_is_identifier_name__WEBPACK_IMPORTED_MODULE_10__.name)(name) && !/^[a-z]/.test(name) ? {\n            type: \"Identifier\",\n            name\n        } : {\n            type: \"Literal\",\n            value: name\n        };\n    }\n    // Only literals can be passed in `components` currently.\n    // No identifiers / member expressions.\n    if (result.type === \"Literal\") {\n        const name = /** @type {keyof JSX.IntrinsicElements} */ result.value;\n        return own.call(state.components, name) ? state.components[name] : name;\n    }\n    // Assume component.\n    if (state.evaluater) {\n        return state.evaluater.evaluateExpression(result);\n    }\n    crashEstree(state);\n}\n/**\n * @param {State} state\n * @param {Position | undefined} [place]\n * @returns {never}\n */ function crashEstree(state, place) {\n    const message = new vfile_message__WEBPACK_IMPORTED_MODULE_9__.VFileMessage(\"Cannot handle MDX estrees without `createEvaluater`\", {\n        ancestors: state.ancestors,\n        place,\n        ruleId: \"mdx-estree\",\n        source: \"hast-util-to-jsx-runtime\"\n    });\n    message.file = state.filePath || undefined;\n    message.url = docs + \"#cannot-handle-mdx-estrees-without-createevaluater\";\n    throw message;\n}\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */ function transformStylesToCssCasing(domCasing) {\n    /** @type {Style} */ const cssCasing = {};\n    /** @type {string} */ let from;\n    for(from in domCasing){\n        if (own.call(domCasing, from)) {\n            cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n        }\n    }\n    return cssCasing;\n}\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */ function transformStyleToCssCasing(from) {\n    let to = from.replace(cap, toDash);\n    // Handle `ms-xxx` -> `-ms-xxx`.\n    if (to.slice(0, 3) === \"ms-\") to = \"-\" + to;\n    return to;\n}\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */ function toCamel(_, $1) {\n    return $1.toUpperCase();\n}\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */ function toDash($0) {\n    return \"-\" + $0.toLowerCase();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0NBU0MsR0FFeUQ7QUFDdkI7QUFDb0M7QUFDeEI7QUFDa0I7QUFDUDtBQUNmO0FBQ0c7QUFDSjtBQUUxQyxzQ0FBc0M7QUFDdEMsTUFBTWUsTUFBTSxDQUFDLEVBQUVDLGNBQWM7QUFFN0IsZ0NBQWdDLEdBQ2hDLE1BQU1DLFdBQVcsSUFBSUM7QUFFckIsTUFBTUMsTUFBTTtBQUNaLE1BQU1DLGdCQUFnQjtBQUV0QixrRUFBa0U7QUFDbEUsNkVBQTZFO0FBQzdFLDJFQUEyRTtBQUMzRSxRQUFRO0FBRVIsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCw2REFBNkQ7QUFDN0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0QsTUFBTUMsZ0JBQWdCLElBQUlDLElBQUk7SUFBQztJQUFTO0lBQVM7SUFBUztJQUFTO0NBQUs7QUFFeEUsTUFBTUMsbUJBQW1CLElBQUlELElBQUk7SUFBQztJQUFNO0NBQUs7QUFFN0MsTUFBTUUsT0FBTztBQUViOzs7Ozs7Ozs7O0NBVUMsR0FFTSxTQUFTQyxhQUFhQyxJQUFJLEVBQUVDLE9BQU87SUFDeEMsSUFBSSxDQUFDQSxXQUFXQSxRQUFRQyxRQUFRLEtBQUtDLFdBQVc7UUFDOUMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0lBRUEsTUFBTUMsV0FBV0osUUFBUUksUUFBUSxJQUFJRjtJQUNyQyxtQkFBbUIsR0FDbkIsSUFBSUc7SUFFSixJQUFJTCxRQUFRTSxXQUFXLEVBQUU7UUFDdkIsSUFBSSxPQUFPTixRQUFRTyxNQUFNLEtBQUssWUFBWTtZQUN4QyxNQUFNLElBQUlKLFVBQ1I7UUFFSjtRQUVBRSxTQUFTRyxrQkFBa0JKLFVBQVVKLFFBQVFPLE1BQU07SUFDckQsT0FBTztRQUNMLElBQUksT0FBT1AsUUFBUVMsR0FBRyxLQUFLLFlB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O0lBRUFnQyxZQUFZN0M7QUFDZDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTNkMsWUFBWTdDLEtBQUssRUFBRTRHLEtBQUs7SUFDL0IsTUFBTWpCLFVBQVUsSUFBSXBILHVEQUFZQSxDQUM5Qix1REFDQTtRQUNFMEIsV0FBV0QsTUFBTUMsU0FBUztRQUMxQjJHO1FBQ0FoQixRQUFRO1FBQ1JDLFFBQVE7SUFDVjtJQUVGRixRQUFRRyxJQUFJLEdBQUc5RixNQUFNUixRQUFRLElBQUlGO0lBQ2pDcUcsUUFBUUksR0FBRyxHQUFHOUcsT0FBTztJQUVyQixNQUFNMEc7QUFDUjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0osMkJBQTJCc0IsU0FBUztJQUMzQyxrQkFBa0IsR0FDbEIsTUFBTUMsWUFBWSxDQUFDO0lBQ25CLG1CQUFtQixHQUNuQixJQUFJQztJQUVKLElBQUtBLFFBQVFGLFVBQVc7UUFDdEIsSUFBSXJJLElBQUl5RixJQUFJLENBQUM0QyxXQUFXRSxPQUFPO1lBQzdCRCxTQUFTLENBQUNFLDBCQUEwQkQsTUFBTSxHQUFHRixTQUFTLENBQUNFLEtBQUs7UUFDOUQ7SUFDRjtJQUVBLE9BQU9EO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNFLDBCQUEwQkQsSUFBSTtJQUNyQyxJQUFJRSxLQUFLRixLQUFLZCxPQUFPLENBQUNySCxLQUFLc0k7SUFDM0IsZ0NBQWdDO0lBQ2hDLElBQUlELEdBQUdqQixLQUFLLENBQUMsR0FBRyxPQUFPLE9BQU9pQixLQUFLLE1BQU1BO0lBQ3pDLE9BQU9BO0FBQ1Q7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTZixRQUFRakQsQ0FBQyxFQUFFa0UsRUFBRTtJQUNwQixPQUFPQSxHQUFHQyxXQUFXO0FBQ3ZCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNGLE9BQU9HLEVBQUU7SUFDaEIsT0FBTyxNQUFNQSxHQUFHMUYsV0FBVztBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmtldC1yZXNlYXJjaC8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUvbGliL2luZGV4LmpzPzk4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW1wb3J0IHtJZGVudGlmaWVyLCBMaXRlcmFsLCBNZW1iZXJFeHByZXNzaW9ufSBmcm9tICdlc3RyZWUnXG4gKiBAaW1wb3J0IHtKc3gsIEpzeERldiwgT3B0aW9ucywgUHJvcHN9IGZyb20gJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZSdcbiAqIEBpbXBvcnQge0VsZW1lbnQsIE5vZGVzLCBQYXJlbnRzLCBSb290LCBUZXh0fSBmcm9tICdoYXN0J1xuICogQGltcG9ydCB7TWR4Rmxvd0V4cHJlc3Npb25IYXN0LCBNZHhUZXh0RXhwcmVzc2lvbkhhc3R9IGZyb20gJ21kYXN0LXV0aWwtbWR4LWV4cHJlc3Npb24nXG4gKiBAaW1wb3J0IHtNZHhKc3hGbG93RWxlbWVudEhhc3QsIE1keEpzeFRleHRFbGVtZW50SGFzdH0gZnJvbSAnbWRhc3QtdXRpbC1tZHgtanN4J1xuICogQGltcG9ydCB7TWR4anNFc21IYXN0fSBmcm9tICdtZGFzdC11dGlsLW1keGpzLWVzbSdcbiAqIEBpbXBvcnQge1Bvc2l0aW9ufSBmcm9tICd1bmlzdCdcbiAqIEBpbXBvcnQge0NoaWxkLCBDcmVhdGUsIEZpZWxkLCBTdGF0ZSwgU3R5bGV9IGZyb20gJy4vdHlwZXMuanMnXG4gKi9cblxuaW1wb3J0IHtzdHJpbmdpZnkgYXMgY29tbWFzfSBmcm9tICdjb21tYS1zZXBhcmF0ZWQtdG9rZW5zJ1xuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7bmFtZSBhcyBpc0lkZW50aWZpZXJOYW1lfSBmcm9tICdlc3RyZWUtdXRpbC1pcy1pZGVudGlmaWVyLW5hbWUnXG5pbXBvcnQge3doaXRlc3BhY2V9IGZyb20gJ2hhc3QtdXRpbC13aGl0ZXNwYWNlJ1xuaW1wb3J0IHtmaW5kLCBoYXN0VG9SZWFjdCwgaHRtbCwgc3ZnfSBmcm9tICdwcm9wZXJ0eS1pbmZvcm1hdGlvbidcbmltcG9ydCB7c3RyaW5naWZ5IGFzIHNwYWNlc30gZnJvbSAnc3BhY2Utc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCBzdHlsZVRvT2JqZWN0IGZyb20gJ3N0eWxlLXRvLW9iamVjdCdcbmltcG9ydCB7cG9pbnRTdGFydH0gZnJvbSAndW5pc3QtdXRpbC1wb3NpdGlvbidcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG4vLyBUbyBkbzogbmV4dCBtYWpvcjogYE9iamVjdC5oYXNPd25gLlxuY29uc3Qgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZW1wdHlNYXAgPSBuZXcgTWFwKClcblxuY29uc3QgY2FwID0gL1tBLVpdL2dcbmNvbnN0IGRhc2hTb21ldGhpbmcgPSAvLShbYS16XSkvZ1xuXG4vLyBgcmVhY3QtZG9tYCB0cmlnZ2VycyBhIHdhcm5pbmcgZm9yICphbnkqIHdoaXRlIHNwYWNlIGluIHRhYmxlcy5cbi8vIFRvIGZvbGxvdyBHRk0sIGBtZGFzdC11dGlsLXRvLWhhc3RgIGluamVjdHMgbGluZSBlbmRpbmdzIGJldHdlZW4gZWxlbWVudHMuXG4vLyBPdGhlciB0b29scyBtaWdodCBkbyBzbyB0b28sIGJ1dCB0aGV5IGRvbuKAmXQgZG8gaGVyZSwgc28gd2UgcmVtb3ZlIGFsbCBvZlxuLy8gdGhhdC5cblxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzA4MT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83NTE1Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZW1hcmstcmVhY3QvaXNzdWVzLzY0Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC8yOT4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvMzI+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzQ1Pi5cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSBuZXcgU2V0KFsndGFibGUnLCAndGJvZHknLCAndGhlYWQnLCAndGZvb3QnLCAndHInXSlcblxuY29uc3QgdGFibGVDZWxsRWxlbWVudCA9IG5ldyBTZXQoWyd0ZCcsICd0aCddKVxuXG5jb25zdCBkb2NzID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9oYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgaGFzdCB0cmVlIHRvIHByZWFjdCwgcmVhY3QsIHNvbGlkLCBzdmVsdGUsIHZ1ZSwgZXRjLixcbiAqIHdpdGggYW4gYXV0b21hdGljIEpTWCBydW50aW1lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBKU1ggZWxlbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Kc3hSdW50aW1lKHRyZWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBGcmFnbWVudGAgaW4gb3B0aW9ucycpXG4gIH1cblxuICBjb25zdCBmaWxlUGF0aCA9IG9wdGlvbnMuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIC8qKiBAdHlwZSB7Q3JlYXRlfSAqL1xuICBsZXQgY3JlYXRlXG5cbiAgaWYgKG9wdGlvbnMuZGV2ZWxvcG1lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4REVWICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYGpzeERFVmAgaW4gb3B0aW9ucyB3aGVuIGBkZXZlbG9wbWVudDogdHJ1ZWAnXG4gICAgICApXG4gICAgfVxuXG4gICAgY3JlYXRlID0gZGV2ZWxvcG1lbnRDcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4REVWKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hzYCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMnKVxuICAgIH1cblxuICAgIGNyZWF0ZSA9IHByb2R1Y3Rpb25DcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4LCBvcHRpb25zLmpzeHMpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBGcmFnbWVudDogb3B0aW9ucy5GcmFnbWVudCxcbiAgICBhbmNlc3RvcnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fSxcbiAgICBjcmVhdGUsXG4gICAgZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlOiBvcHRpb25zLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSB8fCAncmVhY3QnLFxuICAgIGV2YWx1YXRlcjogb3B0aW9ucy5jcmVhdGVFdmFsdWF0ZXIgPyBvcHRpb25zLmNyZWF0ZUV2YWx1YXRlcigpIDogdW5kZWZpbmVkLFxuICAgIGZpbGVQYXRoLFxuICAgIGlnbm9yZUludmFsaWRTdHlsZTogb3B0aW9ucy5pZ25vcmVJbnZhbGlkU3R5bGUgfHwgZmFsc2UsXG4gICAgcGFzc0tleXM6IG9wdGlvbnMucGFzc0tleXMgIT09IGZhbHNlLFxuICAgIHBhc3NOb2RlOiBvcHRpb25zLnBhc3NOb2RlIHx8IGZhbHNlLFxuICAgIHNjaGVtYTogb3B0aW9ucy5zcGFjZSA9PT0gJ3N2ZycgPyBzdmcgOiBodG1sLFxuICAgIHN0eWxlUHJvcGVydHlOYW1lQ2FzZTogb3B0aW9ucy5zdHlsZVByb3BlcnR5TmFtZUNhc2UgfHwgJ2RvbScsXG4gICAgdGFibGVDZWxsQWxpZ25Ub1N0eWxlOiBvcHRpb25zLnRhYmxlQ2VsbEFsaWduVG9TdHlsZSAhPT0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgdHJlZSwgdW5kZWZpbmVkKVxuXG4gIC8vIEpTWCBlbGVtZW50LlxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gVGV4dCBub2RlIG9yIHNvbWV0aGluZyB0aGF0IHR1cm5lZCBpbnRvIG5vdGhpbmcuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUoXG4gICAgdHJlZSxcbiAgICBzdGF0ZS5GcmFnbWVudCxcbiAgICB7Y2hpbGRyZW46IHJlc3VsdCB8fCB1bmRlZmluZWR9LFxuICAgIHVuZGVmaW5lZFxuICApXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG9uZShzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIHJldHVybiBlbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAnbWR4Rmxvd0V4cHJlc3Npb24nIHx8IG5vZGUudHlwZSA9PT0gJ21keFRleHRFeHByZXNzaW9uJykge1xuICAgIHJldHVybiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fCBub2RlLnR5cGUgPT09ICdtZHhKc3hUZXh0RWxlbWVudCcpIHtcbiAgICByZXR1cm4gbWR4SnN4RWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ21keGpzRXNtJykge1xuICAgIHJldHVybiBtZHhFc20oc3RhdGUsIG5vZGUpXG4gIH1cblxuICBpZiAobm9kZS50eXBlID09PSAncm9vdCcpIHtcbiAgICByZXR1cm4gcm9vdChzdGF0ZSwgbm9kZSwga2V5KVxuICB9XG5cbiAgaWYgKG5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHRleHQoc3RhdGUsIG5vZGUpXG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgQ3VycmVudCBub2RlLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hXG5cbiAgaWYgKG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBwYXJlbnRTY2hlbWEuc3BhY2UgPT09ICdodG1sJykge1xuICAgIHNjaGVtYSA9IHN2Z1xuICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICB9XG5cbiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSlcblxuICBjb25zdCB0eXBlID0gZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBub2RlLnRhZ05hbWUsIGZhbHNlKVxuICBjb25zdCBwcm9wcyA9IGNyZWF0ZUVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSlcbiAgbGV0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpXG5cbiAgaWYgKHRhYmxlRWxlbWVudHMuaGFzKG5vZGUudGFnTmFtZSkpIHtcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnID8gIXdoaXRlc3BhY2UoY2hpbGQpIDogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBhZGROb2RlKHN0YXRlLCBwcm9wcywgdHlwZSwgbm9kZSlcbiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKVxuXG4gIC8vIFJlc3RvcmUuXG4gIHN0YXRlLmFuY2VzdG9ycy5wb3AoKVxuICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpXG59XG5cbi8qKlxuICogSGFuZGxlIE1EWCBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4Rmxvd0V4cHJlc3Npb25IYXN0IHwgTWR4VGV4dEV4cHJlc3Npb25IYXN0fSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKSB7XG4gIGlmIChub2RlLmRhdGEgJiYgbm9kZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gbm9kZS5kYXRhLmVzdHJlZVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwcm9ncmFtLmJvZHlbMF1cbiAgICBhc3NlcnQoZXhwcmVzc2lvbi50eXBlID09PSAnRXhwcmVzc2lvblN0YXRlbWVudCcpXG5cbiAgICAvLyBBc3N1bWUgcmVzdWx0IGlzIGEgY2hpbGQuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Q2hpbGQgfCB1bmRlZmluZWR9ICovIChcbiAgICAgIHN0YXRlLmV2YWx1YXRlci5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbi5leHByZXNzaW9uKVxuICAgIClcbiAgfVxuXG4gIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEhhbmRsZSBNRFggRVNNLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4anNFc21IYXN0fSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiBtZHhFc20oc3RhdGUsIG5vZGUpIHtcbiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikge1xuICAgIC8vIEFzc3VtZSByZXN1bHQgaXMgYSBjaGlsZC5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8gKFxuICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlUHJvZ3JhbShub2RlLmRhdGEuZXN0cmVlKVxuICAgIClcbiAgfVxuXG4gIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEhhbmRsZSBNRFggSlNYLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7TWR4SnN4Rmxvd0VsZW1lbnRIYXN0IHwgTWR4SnN4VGV4dEVsZW1lbnRIYXN0fSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG1keEpzeEVsZW1lbnQoc3RhdGUsIG5vZGUsIGtleSkge1xuICBjb25zdCBwYXJlbnRTY2hlbWEgPSBzdGF0ZS5zY2hlbWFcbiAgbGV0IHNjaGVtYSA9IHBhcmVudFNjaGVtYVxuXG4gIGlmIChub2RlLm5hbWUgPT09ICdzdmcnICYmIHBhcmVudFNjaGVtYS5zcGFjZSA9PT0gJ2h0bWwnKSB7XG4gICAgc2NoZW1hID0gc3ZnXG4gICAgc3RhdGUuc2NoZW1hID0gc2NoZW1hXG4gIH1cblxuICBzdGF0ZS5hbmNlc3RvcnMucHVzaChub2RlKVxuXG4gIGNvbnN0IHR5cGUgPVxuICAgIG5vZGUubmFtZSA9PT0gbnVsbFxuICAgICAgPyBzdGF0ZS5GcmFnbWVudFxuICAgICAgOiBmaW5kQ29tcG9uZW50RnJvbU5hbWUoc3RhdGUsIG5vZGUubmFtZSwgdHJ1ZSlcbiAgY29uc3QgcHJvcHMgPSBjcmVhdGVKc3hFbGVtZW50UHJvcHMoc3RhdGUsIG5vZGUpXG4gIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW4oc3RhdGUsIG5vZGUpXG5cbiAgYWRkTm9kZShzdGF0ZSwgcHJvcHMsIHR5cGUsIG5vZGUpXG4gIGFkZENoaWxkcmVuKHByb3BzLCBjaGlsZHJlbilcblxuICAvLyBSZXN0b3JlLlxuICBzdGF0ZS5hbmNlc3RvcnMucG9wKClcbiAgc3RhdGUuc2NoZW1hID0gcGFyZW50U2NoZW1hXG5cbiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KVxufVxuXG4vKipcbiAqIEhhbmRsZSByb290LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7Um9vdH0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0ga2V5XG4gKiAgIEtleS5cbiAqIEByZXR1cm5zIHtDaGlsZCB8IHVuZGVmaW5lZH1cbiAqICAgQ2hpbGQsIG9wdGlvbmFsLlxuICovXG5mdW5jdGlvbiByb290KHN0YXRlLCBub2RlLCBrZXkpIHtcbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgY29uc3QgcHJvcHMgPSB7fVxuXG4gIGFkZENoaWxkcmVuKHByb3BzLCBjcmVhdGVDaGlsZHJlbihzdGF0ZSwgbm9kZSkpXG5cbiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShub2RlLCBzdGF0ZS5GcmFnbWVudCwgcHJvcHMsIGtleSlcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGV4dC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBfXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7VGV4dH0gbm9kZVxuICogICBDdXJyZW50IG5vZGUuXG4gKiBAcmV0dXJucyB7Q2hpbGQgfCB1bmRlZmluZWR9XG4gKiAgIENoaWxkLCBvcHRpb25hbC5cbiAqL1xuZnVuY3Rpb24gdGV4dChfLCBub2RlKSB7XG4gIHJldHVybiBub2RlLnZhbHVlXG59XG5cbi8qKlxuICogQWRkIGBub2RlYCB0byBwcm9wcy5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBQcm9wcy5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdHlwZVxuICogICBUeXBlLlxuICogQHBhcmFtIHtFbGVtZW50IHwgTWR4SnN4Rmxvd0VsZW1lbnRIYXN0IHwgTWR4SnN4VGV4dEVsZW1lbnRIYXN0fSBub2RlXG4gKiAgIE5vZGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBhZGROb2RlKHN0YXRlLCBwcm9wcywgdHlwZSwgbm9kZSkge1xuICAvLyBJZiB0aGlzIGlzIHN3YXBwZWQgb3V0IGZvciBhIGNvbXBvbmVudDpcbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSBzdGF0ZS5GcmFnbWVudCAmJiBzdGF0ZS5wYXNzTm9kZSkge1xuICAgIHByb3BzLm5vZGUgPSBub2RlXG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgY2hpbGRyZW4gdG8gcHJvcHMuXG4gKlxuICogQHBhcmFtIHtQcm9wc30gcHJvcHNcbiAqICAgUHJvcHMuXG4gKiBAcGFyYW0ge0FycmF5PENoaWxkPn0gY2hpbGRyZW5cbiAqICAgQ2hpbGRyZW4uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBhZGRDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNoaWxkcmVuLmxlbmd0aCA+IDEgPyBjaGlsZHJlbiA6IGNoaWxkcmVuWzBdXG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHByb3BzLmNoaWxkcmVuID0gdmFsdWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gX1xuICogICBQYXRoIHRvIGZpbGUuXG4gKiBAcGFyYW0ge0pzeH0ganN4XG4gKiAgIER5bmFtaWMuXG4gKiBAcGFyYW0ge0pzeH0ganN4c1xuICogICBTdGF0aWMuXG4gKiBAcmV0dXJucyB7Q3JlYXRlfVxuICogICBDcmVhdGUgYSBwcm9kdWN0aW9uIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHByb2R1Y3Rpb25DcmVhdGUoXywganN4LCBqc3hzKSB7XG4gIHJldHVybiBjcmVhdGVcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGZ1bmN0aW9uIGNyZWF0ZShfLCB0eXBlLCBwcm9wcywga2V5KSB7XG4gICAgLy8gT25seSBhbiBhcnJheSB3aGVuIHRoZXJlIGFyZSAyIG9yIG1vcmUgY2hpbGRyZW4uXG4gICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pXG4gICAgY29uc3QgZm4gPSBpc1N0YXRpY0NoaWxkcmVuID8ganN4cyA6IGpzeFxuICAgIHJldHVybiBrZXkgPyBmbih0eXBlLCBwcm9wcywga2V5KSA6IGZuKHR5cGUsIHByb3BzKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVQYXRoXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4RGV2fSBqc3hERVZcbiAqICAgRGV2ZWxvcG1lbnQuXG4gKiBAcmV0dXJucyB7Q3JlYXRlfVxuICogICBDcmVhdGUgYSBkZXZlbG9wbWVudCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBkZXZlbG9wbWVudENyZWF0ZShmaWxlUGF0aCwganN4REVWKSB7XG4gIHJldHVybiBjcmVhdGVcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGZ1bmN0aW9uIGNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KSB7XG4gICAgLy8gT25seSBhbiBhcnJheSB3aGVuIHRoZXJlIGFyZSAyIG9yIG1vcmUgY2hpbGRyZW4uXG4gICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pXG4gICAgY29uc3QgcG9pbnQgPSBwb2ludFN0YXJ0KG5vZGUpXG4gICAgcmV0dXJuIGpzeERFVihcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICB7XG4gICAgICAgIGNvbHVtbk51bWJlcjogcG9pbnQgPyBwb2ludC5jb2x1bW4gLSAxIDogdW5kZWZpbmVkLFxuICAgICAgICBmaWxlTmFtZTogZmlsZVBhdGgsXG4gICAgICAgIGxpbmVOdW1iZXI6IHBvaW50ID8gcG9pbnQubGluZSA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBwcm9wcyBmcm9tIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiAgIEN1cnJlbnQgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtQcm9wc31cbiAqICAgUHJvcHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSkge1xuICAvKiogQHR5cGUge1Byb3BzfSAqL1xuICBjb25zdCBwcm9wcyA9IHt9XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICBsZXQgYWxpZ25WYWx1ZVxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IHByb3BcblxuICBmb3IgKHByb3AgaW4gbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3AgIT09ICdjaGlsZHJlbicgJiYgb3duLmNhbGwobm9kZS5wcm9wZXJ0aWVzLCBwcm9wKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUHJvcGVydHkoc3RhdGUsIHByb3AsIG5vZGUucHJvcGVydGllc1twcm9wXSlcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSByZXN1bHRcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RhdGUudGFibGVDZWxsQWxpZ25Ub1N0eWxlICYmXG4gICAgICAgICAga2V5ID09PSAnYWxpZ24nICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIHRhYmxlQ2VsbEVsZW1lbnQuaGFzKG5vZGUudGFnTmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgYWxpZ25WYWx1ZSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNba2V5XSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYWxpZ25WYWx1ZSkge1xuICAgIC8vIEFzc3VtZSBzdHlsZSBpcyBhbiBvYmplY3QuXG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAocHJvcHMuc3R5bGUgfHwgKHByb3BzLnN0eWxlID0ge30pKVxuICAgIHN0eWxlW3N0YXRlLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSA9PT0gJ2NzcycgPyAndGV4dC1hbGlnbicgOiAndGV4dEFsaWduJ10gPVxuICAgICAgYWxpZ25WYWx1ZVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbi8qKlxuICogQ3JlYXRlIHByb3BzIGZyb20gYSBKU1ggZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge01keEpzeEZsb3dFbGVtZW50SGFzdCB8IE1keEpzeFRleHRFbGVtZW50SGFzdH0gbm9kZVxuICogICBDdXJyZW50IEpTWCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb3BzfVxuICogICBQcm9wcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSnN4RWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7UHJvcHN9ICovXG4gIGNvbnN0IHByb3BzID0ge31cblxuICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBub2RlLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdtZHhKc3hFeHByZXNzaW9uQXR0cmlidXRlJykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5kYXRhICYmIGF0dHJpYnV0ZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHtcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGF0dHJpYnV0ZS5kYXRhLmVzdHJlZVxuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgIGFzc2VydChleHByZXNzaW9uLnR5cGUgPT09ICdFeHByZXNzaW9uU3RhdGVtZW50JylcbiAgICAgICAgY29uc3Qgb2JqZWN0RXhwcmVzc2lvbiA9IGV4cHJlc3Npb24uZXhwcmVzc2lvblxuICAgICAgICBhc3NlcnQob2JqZWN0RXhwcmVzc2lvbi50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0RXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzBdXG4gICAgICAgIGFzc2VydChwcm9wZXJ0eS50eXBlID09PSAnU3ByZWFkRWxlbWVudCcpXG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKHByb3BlcnR5LmFyZ3VtZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIEpTWCwgdGhlIGF1dGhvciBpcyByZXNwb25zaWJsZSBvZiBwYXNzaW5nIGluIHRoZSBjb3JyZWN0IHZhbHVlcy5cbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGUubmFtZVxuICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqL1xuICAgICAgbGV0IHZhbHVlXG5cbiAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgJiYgdHlwZW9mIGF0dHJpYnV0ZS52YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZS5kYXRhICYmXG4gICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmRhdGEuZXN0cmVlICYmXG4gICAgICAgICAgc3RhdGUuZXZhbHVhdGVyXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBhdHRyaWJ1dGUudmFsdWUuZGF0YS5lc3RyZWVcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdXG4gICAgICAgICAgYXNzZXJ0KGV4cHJlc3Npb24udHlwZSA9PT0gJ0V4cHJlc3Npb25TdGF0ZW1lbnQnKVxuICAgICAgICAgIHZhbHVlID0gc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLmV4cHJlc3Npb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlID09PSBudWxsID8gdHJ1ZSA6IGF0dHJpYnV0ZS52YWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBBc3N1bWUgYSBwcm9wLlxuICAgICAgcHJvcHNbbmFtZV0gPSAvKiogQHR5cGUge1Byb3BzW2tleW9mIFByb3BzXX0gKi8gKHZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG4vKipcbiAqIENyZWF0ZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1BhcmVudHN9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5PENoaWxkPn1cbiAqICAgQ2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2hpbGQ+fSAqL1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgLy8gTm90ZTogdGVzdCB0aGlzIHdoZW4gU29saWQgZG9lc27igJl0IHdhbnQgdG8gbWVyZ2UgbXkgdXBjb21pbmcgUFIuXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0IGNvdW50c0J5TmFtZSA9IHN0YXRlLnBhc3NLZXlzID8gbmV3IE1hcCgpIDogZW1wdHlNYXBcblxuICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGlmIChzdGF0ZS5wYXNzS2V5cykge1xuICAgICAgY29uc3QgbmFtZSA9XG4gICAgICAgIGNoaWxkLnR5cGUgPT09ICdlbGVtZW50J1xuICAgICAgICAgID8gY2hpbGQudGFnTmFtZVxuICAgICAgICAgIDogY2hpbGQudHlwZSA9PT0gJ21keEpzeEZsb3dFbGVtZW50JyB8fFxuICAgICAgICAgICAgICBjaGlsZC50eXBlID09PSAnbWR4SnN4VGV4dEVsZW1lbnQnXG4gICAgICAgICAgICA/IGNoaWxkLm5hbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzQnlOYW1lLmdldChuYW1lKSB8fCAwXG4gICAgICAgIGtleSA9IG5hbWUgKyAnLScgKyBjb3VudFxuICAgICAgICBjb3VudHNCeU5hbWUuc2V0KG5hbWUsIGNvdW50ICsgMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBvbmUoc3RhdGUsIGNoaWxkLCBrZXkpXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSBjaGlsZHJlbi5wdXNoKHJlc3VsdClcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vKipcbiAqIEhhbmRsZSBhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgIEtleS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogICBoYXN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge0ZpZWxkIHwgdW5kZWZpbmVkfVxuICogICBGaWVsZCBmb3IgcnVudGltZSwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICBjb25zdCBpbmZvID0gZmluZChzdGF0ZS5zY2hlbWEsIHByb3ApXG5cbiAgLy8gSWdub3JlIG51bGxpc2ggYW5kIGBOYU5gIHZhbHVlcy5cbiAgaWYgKFxuICAgIHZhbHVlID09PSBudWxsIHx8XG4gICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE51bWJlci5pc05hTih2YWx1ZSkpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gQWNjZXB0IGBhcnJheWAuXG4gICAgLy8gTW9zdCBwcm9wcyBhcmUgc3BhY2Utc2VwYXJhdGVkLlxuICAgIHZhbHVlID0gaW5mby5jb21tYVNlcGFyYXRlZCA/IGNvbW1hcyh2YWx1ZSkgOiBzcGFjZXModmFsdWUpXG4gIH1cblxuICAvLyBSZWFjdCBvbmx5IGFjY2VwdHMgYHN0eWxlYCBhcyBvYmplY3QuXG4gIGlmIChpbmZvLnByb3BlcnR5ID09PSAnc3R5bGUnKSB7XG4gICAgbGV0IHN0eWxlT2JqZWN0ID1cbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHBhcnNlU3R5bGUoc3RhdGUsIFN0cmluZyh2YWx1ZSkpXG5cbiAgICBpZiAoc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAnY3NzJykge1xuICAgICAgc3R5bGVPYmplY3QgPSB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhzdHlsZU9iamVjdClcbiAgICB9XG5cbiAgICByZXR1cm4gWydzdHlsZScsIHN0eWxlT2JqZWN0XVxuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzdGF0ZS5lbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgPT09ICdyZWFjdCcgJiYgaW5mby5zcGFjZVxuICAgICAgPyBoYXN0VG9SZWFjdFtpbmZvLnByb3BlcnR5XSB8fCBpbmZvLnByb3BlcnR5XG4gICAgICA6IGluZm8uYXR0cmlidXRlLFxuICAgIHZhbHVlXG4gIF1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIENTUyBkZWNsYXJhdGlvbiB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiAgIENTUyBkZWNsYXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7U3R5bGV9XG4gKiAgIFByb3BlcnRpZXMuXG4gKiBAdGhyb3dzXG4gKiAgIFRocm93cyBgVkZpbGVNZXNzYWdlYCB3aGVuIENTUyBjYW5ub3QgYmUgcGFyc2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZVN0eWxlKHN0YXRlLCB2YWx1ZSkge1xuICAvKiogQHR5cGUge1N0eWxlfSAqL1xuICBjb25zdCByZXN1bHQgPSB7fVxuXG4gIHRyeSB7XG4gICAgc3R5bGVUb09iamVjdCh2YWx1ZSwgcmVwbGFjZXIpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFzdGF0ZS5pZ25vcmVJbnZhbGlkU3R5bGUpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gLyoqIEB0eXBlIHtFcnJvcn0gKi8gKGVycm9yKVxuICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBWRmlsZU1lc3NhZ2UoJ0Nhbm5vdCBwYXJzZSBgc3R5bGVgIGF0dHJpYnV0ZScsIHtcbiAgICAgICAgYW5jZXN0b3JzOiBzdGF0ZS5hbmNlc3RvcnMsXG4gICAgICAgIGNhdXNlLFxuICAgICAgICBydWxlSWQ6ICdzdHlsZScsXG4gICAgICAgIHNvdXJjZTogJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZSdcbiAgICAgIH0pXG4gICAgICBtZXNzYWdlLmZpbGUgPSBzdGF0ZS5maWxlUGF0aCB8fCB1bmRlZmluZWRcbiAgICAgIG1lc3NhZ2UudXJsID0gZG9jcyArICcjY2Fubm90LXBhcnNlLXN0eWxlLWF0dHJpYnV0ZSdcblxuICAgICAgdGhyb3cgbWVzc2FnZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcblxuICAvKipcbiAgICogQWRkIGEgQ1NTIHByb3BlcnR5IChub3JtYWwsIHNvIHdpdGggZGFzaGVzKSB0byBgcmVzdWx0YCBhcyBhIERPTSBDU1NcbiAgICogcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqICAgS2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogICBWYWx1ZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlcihuYW1lLCB2YWx1ZSkge1xuICAgIGxldCBrZXkgPSBuYW1lXG5cbiAgICBpZiAoa2V5LnNsaWNlKDAsIDIpICE9PSAnLS0nKSB7XG4gICAgICBpZiAoa2V5LnNsaWNlKDAsIDQpID09PSAnLW1zLScpIGtleSA9ICdtcy0nICsga2V5LnNsaWNlKDQpXG4gICAgICBrZXkgPSBrZXkucmVwbGFjZShkYXNoU29tZXRoaW5nLCB0b0NhbWVsKVxuICAgIH1cblxuICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIEpTWCBuYW1lIGZyb20gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgVG8gZG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogICBOYW1lLlxuICogQHBhcmFtIHtib29sZWFufSBhbGxvd0V4cHJlc3Npb25cbiAqICAgQWxsb3cgbWVtYmVyIGV4cHJlc3Npb25zIGFuZCBpZGVudGlmaWVycy5cbiAqIEByZXR1cm5zIHt1bmtub3dufVxuICogICBUbyBkby5cbiAqL1xuZnVuY3Rpb24gZmluZENvbXBvbmVudEZyb21OYW1lKHN0YXRlLCBuYW1lLCBhbGxvd0V4cHJlc3Npb24pIHtcbiAgLyoqIEB0eXBlIHtJZGVudGlmaWVyIHwgTGl0ZXJhbCB8IE1lbWJlckV4cHJlc3Npb259ICovXG4gIGxldCByZXN1bHRcblxuICBpZiAoIWFsbG93RXhwcmVzc2lvbikge1xuICAgIHJlc3VsdCA9IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBuYW1lfVxuICB9IGVsc2UgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gbmFtZS5zcGxpdCgnLicpXG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICAvKiogQHR5cGUge0lkZW50aWZpZXIgfCBMaXRlcmFsIHwgTWVtYmVyRXhwcmVzc2lvbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgbm9kZVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBpZGVudGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIC8qKiBAdHlwZSB7SWRlbnRpZmllciB8IExpdGVyYWx9ICovXG4gICAgICBjb25zdCBwcm9wID0gaXNJZGVudGlmaWVyTmFtZShpZGVudGlmaWVyc1tpbmRleF0pXG4gICAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZTogaWRlbnRpZmllcnNbaW5kZXhdfVxuICAgICAgICA6IHt0eXBlOiAnTGl0ZXJhbCcsIHZhbHVlOiBpZGVudGlmaWVyc1tpbmRleF19XG4gICAgICBub2RlID0gbm9kZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIG9iamVjdDogbm9kZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IEJvb2xlYW4oaW5kZXggJiYgcHJvcC50eXBlID09PSAnTGl0ZXJhbCcpLFxuICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICA6IHByb3BcbiAgICB9XG5cbiAgICBhc3NlcnQobm9kZSwgJ2Fsd2F5cyBhIHJlc3VsdCcpXG4gICAgcmVzdWx0ID0gbm9kZVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9XG4gICAgICBpc0lkZW50aWZpZXJOYW1lKG5hbWUpICYmICEvXlthLXpdLy50ZXN0KG5hbWUpXG4gICAgICAgID8ge3R5cGU6ICdJZGVudGlmaWVyJywgbmFtZX1cbiAgICAgICAgOiB7dHlwZTogJ0xpdGVyYWwnLCB2YWx1ZTogbmFtZX1cbiAgfVxuXG4gIC8vIE9ubHkgbGl0ZXJhbHMgY2FuIGJlIHBhc3NlZCBpbiBgY29tcG9uZW50c2AgY3VycmVudGx5LlxuICAvLyBObyBpZGVudGlmaWVycyAvIG1lbWJlciBleHByZXNzaW9ucy5cbiAgaWYgKHJlc3VsdC50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICBjb25zdCBuYW1lID0gLyoqIEB0eXBlIHtrZXlvZiBKU1guSW50cmluc2ljRWxlbWVudHN9ICovIChyZXN1bHQudmFsdWUpXG5cbiAgICByZXR1cm4gb3duLmNhbGwoc3RhdGUuY29tcG9uZW50cywgbmFtZSkgPyBzdGF0ZS5jb21wb25lbnRzW25hbWVdIDogbmFtZVxuICB9XG5cbiAgLy8gQXNzdW1lIGNvbXBvbmVudC5cbiAgaWYgKHN0YXRlLmV2YWx1YXRlcikge1xuICAgIHJldHVybiBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKHJlc3VsdClcbiAgfVxuXG4gIGNyYXNoRXN0cmVlKHN0YXRlKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge1Bvc2l0aW9uIHwgdW5kZWZpbmVkfSBbcGxhY2VdXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyYXNoRXN0cmVlKHN0YXRlLCBwbGFjZSkge1xuICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZShcbiAgICAnQ2Fubm90IGhhbmRsZSBNRFggZXN0cmVlcyB3aXRob3V0IGBjcmVhdGVFdmFsdWF0ZXJgJyxcbiAgICB7XG4gICAgICBhbmNlc3RvcnM6IHN0YXRlLmFuY2VzdG9ycyxcbiAgICAgIHBsYWNlLFxuICAgICAgcnVsZUlkOiAnbWR4LWVzdHJlZScsXG4gICAgICBzb3VyY2U6ICdoYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUnXG4gICAgfVxuICApXG4gIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHVuZGVmaW5lZFxuICBtZXNzYWdlLnVybCA9IGRvY3MgKyAnI2Nhbm5vdC1oYW5kbGUtbWR4LWVzdHJlZXMtd2l0aG91dC1jcmVhdGVldmFsdWF0ZXInXG5cbiAgdGhyb3cgbWVzc2FnZVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIERPTSBjYXNpbmcgc3R5bGUgb2JqZWN0IHRvIGEgQ1NTIGNhc2luZyBzdHlsZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHlsZX0gZG9tQ2FzaW5nXG4gKiBAcmV0dXJucyB7U3R5bGV9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlc1RvQ3NzQ2FzaW5nKGRvbUNhc2luZykge1xuICAvKiogQHR5cGUge1N0eWxlfSAqL1xuICBjb25zdCBjc3NDYXNpbmcgPSB7fVxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IGZyb21cblxuICBmb3IgKGZyb20gaW4gZG9tQ2FzaW5nKSB7XG4gICAgaWYgKG93bi5jYWxsKGRvbUNhc2luZywgZnJvbSkpIHtcbiAgICAgIGNzc0Nhc2luZ1t0cmFuc2Zvcm1TdHlsZVRvQ3NzQ2FzaW5nKGZyb20pXSA9IGRvbUNhc2luZ1tmcm9tXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjc3NDYXNpbmdcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBET00gY2FzaW5nIHN0eWxlIGZpZWxkIHRvIGEgQ1NTIGNhc2luZyBzdHlsZSBmaWVsZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVUb0Nzc0Nhc2luZyhmcm9tKSB7XG4gIGxldCB0byA9IGZyb20ucmVwbGFjZShjYXAsIHRvRGFzaClcbiAgLy8gSGFuZGxlIGBtcy14eHhgIC0+IGAtbXMteHh4YC5cbiAgaWYgKHRvLnNsaWNlKDAsIDMpID09PSAnbXMtJykgdG8gPSAnLScgKyB0b1xuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNYWtlIGAkMWAgY2FwaXRhbGl6ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IF9cbiAqICAgV2hhdGV2ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gJDFcbiAqICAgU2luZ2xlIEFTQ0lJIGFscGhhYmV0aWNhbC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIENhcGl0YWxpemVkIGAkMWAuXG4gKi9cbmZ1bmN0aW9uIHRvQ2FtZWwoXywgJDEpIHtcbiAgcmV0dXJuICQxLnRvVXBwZXJDYXNlKClcbn1cblxuLyoqXG4gKiBNYWtlIGAkMGAgZGFzaCBjYXNlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gJDBcbiAqICAgQ2FwaXRhbGl6ZWQgQVNDSUkgbGV0ZXIuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogICBEYXNoIGFuZCBsb3dlciBsZXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRvRGFzaCgkMCkge1xuICByZXR1cm4gJy0nICsgJDAudG9Mb3dlckNhc2UoKVxufVxuIl0sIm5hbWVzIjpbInN0cmluZ2lmeSIsImNvbW1hcyIsIm9rIiwiYXNzZXJ0IiwibmFtZSIsImlzSWRlbnRpZmllck5hbWUiLCJ3aGl0ZXNwYWNlIiwiZmluZCIsImhhc3RUb1JlYWN0IiwiaHRtbCIsInN2ZyIsInNwYWNlcyIsInN0eWxlVG9PYmplY3QiLCJwb2ludFN0YXJ0IiwiVkZpbGVNZXNzYWdlIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJlbXB0eU1hcCIsIk1hcCIsImNhcCIsImRhc2hTb21ldGhpbmciLCJ0YWJsZUVsZW1lbnRzIiwiU2V0IiwidGFibGVDZWxsRWxlbWVudCIsImRvY3MiLCJ0b0pzeFJ1bnRpbWUiLCJ0cmVlIiwib3B0aW9ucyIsIkZyYWdtZW50IiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiZmlsZVBhdGgiLCJjcmVhdGUiLCJkZXZlbG9wbWVudCIsImpzeERFViIsImRldmVsb3BtZW50Q3JlYXRlIiwianN4IiwianN4cyIsInByb2R1Y3Rpb25DcmVhdGUiLCJzdGF0ZSIsImFuY2VzdG9ycyIsImNvbXBvbmVudHMiLCJlbGVtZW50QXR0cmlidXRlTmFtZUNhc2UiLCJldmFsdWF0ZXIiLCJjcmVhdGVFdmFsdWF0ZXIiLCJpZ25vcmVJbnZhbGlkU3R5bGUiLCJwYXNzS2V5cyIsInBhc3NOb2RlIiwic2NoZW1hIiwic3BhY2UiLCJzdHlsZVByb3BlcnR5TmFtZUNhc2UiLCJ0YWJsZUNlbGxBbGlnblRvU3R5bGUiLCJyZXN1bHQiLCJvbmUiLCJjaGlsZHJlbiIsIm5vZGUiLCJrZXkiLCJ0eXBlIiwiZWxlbWVudCIsIm1keEV4cHJlc3Npb24iLCJtZHhKc3hFbGVtZW50IiwibWR4RXNtIiwicm9vdCIsInRleHQiLCJwYXJlbnRTY2hlbWEiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiZmluZENvbXBvbmVudEZyb21OYW1lIiwicHJvcHMiLCJjcmVhdGVFbGVtZW50UHJvcHMiLCJjcmVhdGVDaGlsZHJlbiIsImhhcyIsImZpbHRlciIsImNoaWxkIiwiYWRkTm9kZSIsImFkZENoaWxkcmVuIiwicG9wIiwiZGF0YSIsImVzdHJlZSIsInByb2dyYW0iLCJleHByZXNzaW9uIiwiYm9keSIsImV2YWx1YXRlRXhwcmVzc2lvbiIsImNyYXNoRXN0cmVlIiwicG9zaXRpb24iLCJldmFsdWF0ZVByb2dyYW0iLCJjcmVhdGVKc3hFbGVtZW50UHJvcHMiLCJfIiwidmFsdWUiLCJsZW5ndGgiLCJpc1N0YXRpY0NoaWxkcmVuIiwiQXJyYXkiLCJpc0FycmF5IiwiZm4iLCJwb2ludCIsImNvbHVtbk51bWJlciIsImNvbHVtbiIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImxpbmUiLCJhbGlnblZhbHVlIiwicHJvcCIsInByb3BlcnRpZXMiLCJjYWxsIiwiY3JlYXRlUHJvcGVydHkiLCJzdHlsZSIsImF0dHJpYnV0ZSIsImF0dHJpYnV0ZXMiLCJvYmplY3RFeHByZXNzaW9uIiwicHJvcGVydHkiLCJPYmplY3QiLCJhc3NpZ24iLCJhcmd1bWVudCIsImluZGV4IiwiY291bnRzQnlOYW1lIiwiY291bnQiLCJnZXQiLCJzZXQiLCJpbmZvIiwiTnVtYmVyIiwiaXNOYU4iLCJjb21tYVNlcGFyYXRlZCIsInN0eWxlT2JqZWN0IiwicGFyc2VTdHlsZSIsIlN0cmluZyIsInRyYW5zZm9ybVN0eWxlc1RvQ3NzQ2FzaW5nIiwicmVwbGFjZXIiLCJlcnJvciIsImNhdXNlIiwibWVzc2FnZSIsInJ1bGVJZCIsInNvdXJjZSIsImZpbGUiLCJ1cmwiLCJzbGljZSIsInJlcGxhY2UiLCJ0b0NhbWVsIiwiYWxsb3dFeHByZXNzaW9uIiwiaW5jbHVkZXMiLCJpZGVudGlmaWVycyIsInNwbGl0Iiwib2JqZWN0IiwiY29tcHV0ZWQiLCJCb29sZWFuIiwib3B0aW9uYWwiLCJ0ZXN0IiwicGxhY2UiLCJkb21DYXNpbmciLCJjc3NDYXNpbmciLCJmcm9tIiwidHJhbnNmb3JtU3R5bGVUb0Nzc0Nhc2luZyIsInRvIiwidG9EYXNoIiwiJDEiLCJ0b1VwcGVyQ2FzZSIsIiQwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ })

};
;